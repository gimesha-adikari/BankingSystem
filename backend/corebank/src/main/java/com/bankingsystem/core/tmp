package com.bankingsystem.mobile.ui.kyc

import android.content.Context
import androidx.camera.core.CameraInfoUnavailableException
import androidx.camera.core.CameraSelector
import androidx.camera.lifecycle.ProcessCameraProvider
import java.io.File
import java.text.SimpleDateFormat
import java.util.Locale
import kotlin.math.max
import kotlin.math.min

internal fun ProcessCameraProvider.hasCameraSafe(selector: CameraSelector): Boolean =
    try { hasCamera(selector) } catch (_: CameraInfoUnavailableException) { false }

internal fun createTempImageFile(context: Context): File {
    val dir = File(context.cacheDir, "images").apply { mkdirs() }
    val ts = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(System.currentTimeMillis())
    return File(dir, "selfie_$ts.jpg")
}

internal fun ArrayDeque<Float>.minVal(): Float =
    this.fold(Float.POSITIVE_INFINITY) { acc, v -> min(acc, v) }

internal fun ArrayDeque<Float>.maxVal(): Float =
    this.fold(Float.NEGATIVE_INFINITY) { acc, v -> max(acc, v) }
package com.bankingsystem.mobile.ui.kyc

import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ColumnScope
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.CreditCard
import androidx.compose.material.icons.filled.Face
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.AssistChip
import androidx.compose.material3.AssistChipDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

@Composable
internal fun KycPanel(
    modifier: Modifier = Modifier,
    content: @Composable ColumnScope.() -> Unit
) {
    val cs = MaterialTheme.colorScheme
    Surface(
        modifier = modifier.fillMaxWidth(),
        shape = RoundedCornerShape(24.dp),
        color = cs.surface.copy(alpha = 0.10f),
        tonalElevation = 0.dp,
        shadowElevation = 12.dp,
        border = BorderStroke(1.dp, cs.outline.copy(alpha = 0.35f))
    ) {
        Column(modifier = Modifier.padding(16.dp), content = content)
    }
}

@Composable
internal fun StepHeaderRow(current: KycStep, modifier: Modifier = Modifier) {
    val steps = listOf(
        Triple(Icons.Filled.CreditCard, "ID", KycStep.Document),
        Triple(Icons.Filled.Face, "Selfie", KycStep.Selfie),
        Triple(Icons.Filled.Home, "Address", KycStep.Address),
        Triple(Icons.Filled.CheckCircle, "Review", KycStep.Review)
    )
    Row(
        modifier = modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.spacedBy(10.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        steps.forEach { (icon, label, step) ->
            val active = step == current
            AssistChip(
                onClick = { },
                label = {
                    Text(
                        label,
                        color = if (active) MaterialTheme.colorScheme.primary
                        else Color.White.copy(0.70f)
                    )
                },
                leadingIcon = {
                    androidx.compose.material3.Icon(
                        imageVector = icon,
                        contentDescription = null,
                        tint = if (active) MaterialTheme.colorScheme.primary
                        else Color.White.copy(0.70f)
                    )
                },
                border = BorderStroke(
                    1.dp,
                    (if (active) MaterialTheme.colorScheme.primary else Color.White).copy(alpha = 0.45f)
                ),
                colors = AssistChipDefaults.assistChipColors(
                    containerColor = Color.White.copy(alpha = if (active) 0.10f else 0.06f)
                )
            )
        }
    }
}

@Composable
internal fun SourceChooserDialog(
    onDismiss: () -> Unit,
    onCamera: () -> Unit,
    onGallery: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Add photo from") },
        text = { Text("Choose a source") },
        confirmButton = { TextButton(onClick = onCamera) { Text("Camera") } },
        dismissButton = { TextButton(onClick = onGallery) { Text("Gallery") } }
    )
}
package com.bankingsystem.mobile.ui.kyc

import android.net.Uri

enum class KycStep { Document, Selfie, Address, Review }

data class DocQuality(
    val blurScore: Float? = null,
    val glareScore: Float? = null,
    val cornerCoverage: Int? = null
)

data class OcrField(
    val label: String,
    val value: String,
    val confidence: Float? = null
)

data class KycUiState(
    val step: KycStep = KycStep.Document,
    val docFront: Uri? = null,
    val docBack: Uri? = null,
    val docQuality: DocQuality = DocQuality(),
    val ocrFields: List<OcrField> = emptyList(),
    val selfie: Uri? = null,
    val livenessScore: Float? = null,
    val faceMatchScore: Float? = null,
    val addressProof: Uri? = null,
    val consentAccepted: Boolean = false
)
@file:Suppress("OPT_IN_IS_NOT_ENABLED", "OPT_IN_USAGE")

package com.bankingsystem.mobile.ui.kyc

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import androidx.hilt.navigation.compose.hiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File

private const val DEV_PREVIEW = false

private enum class PickTarget { NONE, FRONT, BACK, SELFIE, ADDRESS }

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun KycRoute(
    userName: String,
    onNavigate: (String) -> Unit = {}
) {
    val vm: KycViewModel = hiltViewModel()
    val ui by vm.ui.collectAsState()
    val uploading by vm.uploading.collectAsState()
    val ctx = LocalContext.current
    val scope = rememberCoroutineScope()

    LaunchedEffect(ui.docFront, ui.docBack) {
        val q = withContext(Dispatchers.Default) {
            val fronts = ui.docFront?.let { decodeBitmapForAnalyze(ctx, it)?.let(::computeDocQuality) }
            val backs  = ui.docBack ?.let { decodeBitmapForAnalyze(ctx, it)?.let(::computeDocQuality) }
            if (fronts == null && backs == null) null
            else DocQuality(
                blurScore      = listOfNotNull(fronts?.blurScore, backs?.blurScore).minOrNull(),
                glareScore     = listOfNotNull(fronts?.glareScore, backs?.glareScore).minOrNull(),
                cornerCoverage = listOfNotNull(fronts?.cornerCoverage, backs?.cornerCoverage).minOrNull()
            )
        }
        vm.setDocQuality(q ?: DocQuality())
        val d = q ?: DocQuality()
        Log.d("KYC",
            "docFront=${ui.docFront!=null}, docBack=${ui.docBack!=null}, " +
                    "blur=${d.blurScore}, glare=${d.glareScore}, corners=${d.cornerCoverage}"
        )
    }


    var showChooser by remember { mutableStateOf(false) }
    var target by remember { mutableStateOf(PickTarget.NONE) }

    var pendingCameraUri by remember { mutableStateOf<Uri?>(null) }
    var pendingCameraTarget by remember { mutableStateOf(PickTarget.NONE) }
    var lastRequestedTarget by remember { mutableStateOf(PickTarget.NONE) }

    val takePicture = rememberLauncherForActivityResult(
        ActivityResultContracts.TakePicture()
    ) { ok ->
        if (ok) {
            when (pendingCameraTarget) {
                PickTarget.FRONT -> vm.setDocFront(pendingCameraUri)
                PickTarget.BACK -> vm.setDocBack(pendingCameraUri)
                PickTarget.SELFIE -> {
                    vm.setSelfie(pendingCameraUri)
                    vm.setLiveness(0.9f)
                    vm.setFaceMatch(0.9f)
                }
                PickTarget.ADDRESS -> vm.setAddressProof(pendingCameraUri)
                else -> {}
            }
        }
        pendingCameraTarget = PickTarget.NONE
        pendingCameraUri = null
    }

    val pickVisual = rememberLauncherForActivityResult(
        ActivityResultContracts.PickVisualMedia()
    ) { uri ->
        uri ?: return@rememberLauncherForActivityResult
        when (target) {
            PickTarget.FRONT -> vm.setDocFront(uri)
            PickTarget.BACK -> vm.setDocBack(uri)
            PickTarget.SELFIE -> {
                vm.setSelfie(uri)
                vm.setLiveness(0.9f)
                vm.setFaceMatch(0.9f)
            }
            PickTarget.ADDRESS -> vm.setAddressProof(uri)
            else -> {}
        }
    }

    val requestCameraPerm = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { granted ->
        if (granted && lastRequestedTarget != PickTarget.NONE) {
            pendingCameraUri?.let { takePicture.launch(it) }
        }
    }

    fun createTempImageUri(local: Context): Uri {
        val dir = File(local.cacheDir, "images").apply { mkdirs() }
        val file = File.createTempFile("kyc_", ".jpg", dir)
        return FileProvider.getUriForFile(local, "${local.packageName}.fileprovider", file)
    }

    fun launchCameraFor(local: Context, which: PickTarget) {
        lastRequestedTarget = which
        val uri = createTempImageUri(local)
        pendingCameraUri = uri
        pendingCameraTarget = which
        val granted = ContextCompat.checkSelfPermission(local, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED
        if (granted) takePicture.launch(uri) else requestCameraPerm.launch(Manifest.permission.CAMERA)
    }

    fun openGalleryFor(which: PickTarget) {
        target = which
        pickVisual.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
    }

    Box(Modifier.fillMaxSize()) {
        when (ui.step) {
            KycStep.Document -> DocumentCaptureScreen(
                frontUri = ui.docFront,
                backUri = ui.docBack,
                onPickFront = { target = PickTarget.FRONT; showChooser = true },
                onRemoveFront = { vm.setDocFront(null) },
                onPickBack = { target = PickTarget.BACK; showChooser = true },
                onRemoveBack = { vm.setDocBack(null) },
                onBack = { onNavigate("Home") },
                onNext = { if (DEV_PREVIEW || vm.canContinueFromDocument()) vm.next() },
                canContinue = !uploading && (DEV_PREVIEW || vm.canContinueFromDocument())
            )
            KycStep.Selfie -> SelfieLivenessScreen(
                onBack = { vm.back() },
                onNext = { if (DEV_PREVIEW || vm.canContinueFromSelfie()) vm.next() },
                canContinue = !uploading && (DEV_PREVIEW || vm.canContinueFromSelfie()),
                selfieUri = ui.selfie,
                onCaptureSelfie = { target = PickTarget.SELFIE; showChooser = true },
                onPickFromGallery = { target = PickTarget.SELFIE; showChooser = true },
                onSelfieReady = { uri ->
                    vm.setSelfie(uri)
                    vm.setLiveness(0.9f)
                    vm.setFaceMatch(0.9f)
                }
            )
            KycStep.Address -> AddressProofScreen(
                proofUri = ui.addressProof,
                onCapture = { target = PickTarget.ADDRESS; showChooser = true },
                onPickFromGallery = { target = PickTarget.ADDRESS; showChooser = true },
                onRemove = { vm.setAddressProof(null) },
                onBack = { vm.back() },
                onNext = { if (DEV_PREVIEW || vm.canContinueFromAddress()) vm.next() },
                canContinue = !uploading && (DEV_PREVIEW || vm.canContinueFromAddress())
            )
            KycStep.Review -> KycReviewScreen(
                onBack = { vm.back() },
                onSubmit = {
                    scope.launch {
                        val ok = vm.submit()
                        if (ok) onNavigate("Home")
                    }
                },
                canSubmit = !uploading && vm.readyToSubmit(),
                consent = ui.consentAccepted,
                onToggleConsent = vm::setConsent
            )
        }

        if (showChooser && target != PickTarget.NONE) {
            SourceChooserDialog(
                onDismiss = { showChooser = false; target = PickTarget.NONE },
                onCamera = { showChooser = false; launchCameraFor(ctx, target) },
                onGallery = { showChooser = false; openGalleryFor(target) }
            )
        }
    }
}
package com.bankingsystem.mobile.ui.kyc

import android.net.Uri
import android.view.Surface
import androidx.camera.core.AspectRatio
import androidx.camera.core.CameraSelector
import androidx.camera.core.ExperimentalGetImage
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.navigationBarsPadding
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.AddAPhoto
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.Button
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedCard
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.lifecycle.compose.LocalLifecycleOwner
import coil.compose.AsyncImage
import com.bankingsystem.mobile.ui.components.FadingAppBackground
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.face.Face
import com.google.mlkit.vision.face.FaceDetection
import com.google.mlkit.vision.face.FaceDetectorOptions
import kotlin.math.abs
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun KycScaffold(
    title: String,
    onBack: () -> Unit,
    bottomBar: @Composable () -> Unit = {},
    content: @Composable (PaddingValues) -> Unit
) {
    Box(Modifier) {
        FadingAppBackground()
        Scaffold(
            containerColor = Color.Transparent,
            topBar = {
                TopAppBar(
                    title = { Text(title, color = Color.White) },
                    navigationIcon = {
                        IconButton(onClick = onBack) {
                            Icon(Icons.AutoMirrored.Filled.ArrowBack, null, tint = Color.White)
                        }
                    },
                    colors = TopAppBarDefaults.topAppBarColors(
                        containerColor = Color.Transparent,
                        scrolledContainerColor = Color.Transparent,
                        titleContentColor = Color.White,
                        navigationIconContentColor = Color.White,
                        actionIconContentColor = Color.White
                    )
                )
            },
            bottomBar = {
                Surface(color = Color.Transparent, tonalElevation = 0.dp, shadowElevation = 0.dp) {
                    bottomBar()
                }
            },
            content = content
        )
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DocumentCaptureScreen(
    frontUri: Uri?,
    backUri: Uri?,
    onPickFront: () -> Unit,
    onRemoveFront: () -> Unit,
    onPickBack: () -> Unit,
    onRemoveBack: () -> Unit,
    onBack: () -> Unit,
    onNext: () -> Unit,
    canContinue: Boolean = false
) {
    KycScaffold(
        title = "Verify your ID",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onNext,
                enabled = canContinue,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Continue") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Document)
            KycPanel {
                Text("Capture both sides of your national ID.", style = MaterialTheme.typography.titleMedium, color = Color.White)
                Spacer(Modifier.height(12.dp))
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                    DocSlot("Front side", frontUri, onPickFront, onRemoveFront, Modifier.weight(1f))
                    DocSlot("Back side", backUri, onPickBack, onRemoveBack, Modifier.weight(1f))
                }
                Spacer(Modifier.height(12.dp))
                OutlinedButton(onClick = onBack) { Text("Back") }
                Spacer(Modifier.height(10.dp))
                if (canContinue) Text("Looks good â€¢ tap Continue", color = Color.White.copy(0.8f))
            }
        }
    }
}

@Composable
private fun DocSlot(
    title: String,
    uri: Uri?,
    onPick: () -> Unit,
    onRemove: () -> Unit,
    modifier: Modifier = Modifier
) {
    val frame = RoundedCornerShape(18.dp)
    val grad = Brush.linearGradient(
        listOf(
            Color(0xFF5B67F3).copy(alpha = 0.22f),
            Color(0xFF5B67F3).copy(alpha = 0.08f)
        )
    )
    Surface(
        modifier = modifier,
        shape = frame,
        tonalElevation = 0.dp,
        border = BorderStroke(1.dp, Color.White.copy(alpha = 0.18f)),
        color = Color.Transparent
    ) {
        Column(
            modifier = Modifier
                .background(grad, frame)
                .padding(14.dp),
            verticalArrangement = Arrangement.spacedBy(10.dp)
        ) {
            Text(title, style = MaterialTheme.typography.titleMedium, color = Color.White)
            if (uri == null) {
                OutlinedCard(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(140.dp),
                    shape = RoundedCornerShape(14.dp),
                    colors = CardDefaults.outlinedCardColors(
                        containerColor = Color.White.copy(alpha = 0.08f),
                        contentColor = Color.White
                    ),
                    border = BorderStroke(1.dp, Color.White.copy(0.15f))
                ) {
                    Box(Modifier.fillMaxWidth().height(140.dp), contentAlignment = Alignment.Center) {
                        OutlinedButton(onClick = onPick) {
                            Icon(Icons.Filled.AddAPhoto, null, tint = Color.White)
                            Spacer(Modifier.width(8.dp))
                            Text("Add photo", color = Color.White)
                        }
                    }
                }
            } else {
                AsyncImage(
                    model = uri,
                    contentDescription = null,
                    contentScale = ContentScale.Crop,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(140.dp)
                        .clip(RoundedCornerShape(14.dp))
                )
                Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {
                    OutlinedButton(onClick = onRemove) {
                        Icon(Icons.Filled.Delete, null, tint = Color.White)
                        Spacer(Modifier.width(6.dp))
                        Text("Remove", color = Color.White)
                    }
                }
            }
        }
    }
}

@androidx.annotation.OptIn(ExperimentalGetImage::class)
@OptIn(ExperimentalMaterial3Api::class, ExperimentalGetImage::class)
@Composable
fun SelfieLivenessScreen(
    onBack: () -> Unit,
    onNext: () -> Unit,
    canContinue: Boolean = true,
    selfieUri: Uri? = null,
    onCaptureSelfie: () -> Unit = {},
    onPickFromGallery: () -> Unit = {},
    onSelfieReady: (Uri) -> Unit = {}
) {
    val ctx = LocalContext.current
    val owner = LocalLifecycleOwner.current
    var error by remember { mutableStateOf<String?>(null) }
    var progress by remember { mutableFloatStateOf(0f) }
    var capturing by remember { mutableStateOf(false) }
    val needCenteredFrames = 8
    val centerTolX = 0.25f
    val centerTolY = 0.28f
    val blinkCloseThr = 0.45f
    val blinkOpenThr = 0.55f
    val yawWindowSize = 18
    val yawMinRange = 3f
    val yawMaxRange = 35f
    var centeredFrames by remember { mutableIntStateOf(0) }
    var lastLeftOpen by remember { mutableStateOf<Boolean?>(null) }
    var lastRightOpen by remember { mutableStateOf<Boolean?>(null) }
    var blinked by remember { mutableStateOf(false) }
    val yawWindow = remember { ArrayDeque<Float>() }
    val previewView = remember(ctx) { PreviewView(ctx).apply { scaleType = PreviewView.ScaleType.FIT_CENTER } }
    val imageCapture = remember {
        ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .setTargetAspectRatio(AspectRatio.RATIO_16_9)
            .build()
    }
    val detector = remember {
        FaceDetection.getClient(
            FaceDetectorOptions.Builder()
                .setPerformanceMode(FaceDetectorOptions.PERFORMANCE_MODE_FAST)
                .setClassificationMode(FaceDetectorOptions.CLASSIFICATION_MODE_ALL)
                .enableTracking()
                .build()
        )
    }
    LaunchedEffect(owner) {
        try {
            val provider = withContext(Dispatchers.Default) {
                ProcessCameraProvider.getInstance(ctx).get()
            }
            val front = CameraSelector.DEFAULT_FRONT_CAMERA
            val back = CameraSelector.DEFAULT_BACK_CAMERA
            val selector = if (provider.hasCameraSafe(front)) front else back
            if (!provider.hasCameraSafe(selector)) {
                error = "No available camera can be found"
                return@LaunchedEffect
            }
            val rotation = previewView.display?.rotation ?: Surface.ROTATION_0
            val preview = Preview.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9)
                .setTargetRotation(rotation)
                .build()
                .also { it.setSurfaceProvider(previewView.surfaceProvider) }
            val mainExec = ContextCompat.getMainExecutor(ctx)

            val analyzer = ImageAnalysis.Analyzer { proxy ->
                val media = proxy.image ?: run { proxy.close(); return@Analyzer }
                val image = InputImage.fromMediaImage(media, proxy.imageInfo.rotationDegrees)
                detector.process(image)
                    .addOnSuccessListener(mainExec) { faces: List<Face> ->
                        if (faces.size == 1) {
                            val f = faces[0]
                            val w = image.width.toFloat()
                            val h = image.height.toFloat()
                            val cx = f.boundingBox.centerX() / w
                            val cy = f.boundingBox.centerY() / h
                            val centered = abs(cx - 0.5f) < centerTolX && abs(cy - 0.5f) < centerTolY
                            centeredFrames = if (centered) (centeredFrames + 1).coerceAtMost(60) else (centeredFrames - 2).coerceAtLeast(0)
                            val centerOk = centeredFrames >= needCenteredFrames

                            val le = f.leftEyeOpenProbability
                            val re = f.rightEyeOpenProbability
                            val openNow = (le != null && le > blinkOpenThr) || (re != null && re > blinkOpenThr)
                            val closedNow = (le != null && le < blinkCloseThr) || (re != null && re < blinkCloseThr)
                            val wasOpen = (lastLeftOpen == true) || (lastRightOpen == true)
                            if (!blinked && wasOpen && closedNow) blinked = true
                            lastLeftOpen = le?.let { it > blinkOpenThr }
                            lastRightOpen = re?.let { it > blinkOpenThr }
                            val blinkOk = blinked && openNow

                            val yaw = f.headEulerAngleY
                            yawWindow.addLast(yaw)
                            if (yawWindow.size > yawWindowSize) yawWindow.removeFirst()
                            val minYaw = yawWindow.minOrNull() ?: 0f
                            val maxYaw = yawWindow.maxOrNull() ?: 0f
                            val yawRange = maxYaw - minYaw
                            val moveOk = yawRange in yawMinRange..yawMaxRange

                            val p1 = if (centerOk) 1f else centeredFrames / needCenteredFrames.toFloat()
                            val p2 = if (blinkOk) 1f else 0f
                            val p3 = if (moveOk) 1f else (yawRange / yawMinRange).coerceIn(0f, 1f)
                            progress = (p1 + p2 + p3) / 3f

                            val satisfied = listOf(centerOk, blinkOk, moveOk).count { it } >= 2
                            if (satisfied && !capturing) {
                                capturing = true
                                val out = createTempImageFile(ctx)
                                val opts = ImageCapture.OutputFileOptions.Builder(out).build()
                                imageCapture.takePicture(
                                    opts,
                                    mainExec,
                                    object : ImageCapture.OnImageSavedCallback {
                                        override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                                            onSelfieReady(Uri.fromFile(out))
                                        }
                                        override fun onError(exc: ImageCaptureException) {
                                            error = exc.message
                                            capturing = false
                                        }
                                    }
                                )
                            }
                        }
                    }
                    .addOnFailureListener(mainExec) { e -> error = e.message }
                    .addOnCompleteListener(mainExec) { proxy.close() }
            }

            val analysis = ImageAnalysis.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9)
                .setTargetRotation(rotation)
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also { it.setAnalyzer(mainExec, analyzer) }

            provider.unbindAll()
            provider.bindToLifecycle(owner, selector, preview, imageCapture, analysis)
            error = null
        } catch (e: Exception) {
            error = e.message ?: "Failed to start camera"
        }
    }

    KycScaffold(
        title = "Face verification",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onNext,
                enabled = canContinue,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Continue") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Selfie)
            KycPanel {
                AndroidView(
                    factory = { previewView },
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(280.dp)
                        .clip(RoundedCornerShape(18.dp))
                )
                LinearProgressIndicator(
                    progress = progress,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 10.dp)
                )
                Text("Center your face in the frame", color = Color.White)
                if (error != null) {
                    Spacer(Modifier.height(6.dp))
                    Text(error!!, color = MaterialTheme.colorScheme.error)
                }
                Spacer(Modifier.height(10.dp))
                Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
                    OutlinedButton(onClick = onPickFromGallery) { Text("Pick from gallery") }
                    OutlinedButton(onClick = onCaptureSelfie, enabled = error == null) { Text("Capture") }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddressProofScreen(
    proofUri: Uri? = null,
    onCapture: () -> Unit = {},
    onPickFromGallery: () -> Unit = {},
    onRemove: () -> Unit = {},
    onBack: () -> Unit,
    onNext: () -> Unit,
    canContinue: Boolean = true
) {
    KycScaffold(
        title = "Proof of address",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onNext,
                enabled = canContinue,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Continue") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Address)
            KycPanel {
                val grad = Brush.linearGradient(
                    listOf(
                        Color(0xFF5B67F3).copy(alpha = 0.22f),
                        Color(0xFF5B67F3).copy(alpha = 0.08f)
                    )
                )
                Surface(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(180.dp),
                    shape = RoundedCornerShape(18.dp),
                    tonalElevation = 0.dp,
                    border = BorderStroke(1.dp, Color.White.copy(alpha = 0.18f)),
                    color = Color.Transparent
                ) {
                    Box(
                        Modifier
                            .background(grad, RoundedCornerShape(18.dp))
                            .fillMaxWidth()
                            .height(180.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        if (proofUri == null) {
                            Text("Upload / capture utility bill, lease, etc.", color = Color.White)
                        } else {
                            AsyncImage(
                                model = proofUri,
                                contentDescription = null,
                                contentScale = ContentScale.Crop,
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .height(180.dp)
                                    .clip(RoundedCornerShape(18.dp))
                            )
                        }
                    }
                }
                Spacer(Modifier.height(10.dp))
                Row(horizontalArrangement = Arrangement.spacedBy(10.dp)) {
                    OutlinedButton(onClick = onPickFromGallery) { Text("Pick from gallery") }
                    OutlinedButton(onClick = onCapture) { Text("Capture") }
                    if (proofUri != null) OutlinedButton(onClick = onRemove) { Text("Remove") }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun KycReviewScreen(
    onBack: () -> Unit,
    onSubmit: () -> Unit,
    canSubmit: Boolean,
    consent: Boolean,
    onToggleConsent: (Boolean) -> Unit
) {
    KycScaffold(
        title = "Review & submit",
        onBack = onBack,
        bottomBar = {
            Button(
                onClick = onSubmit,
                enabled = canSubmit,
                modifier = Modifier
                    .navigationBarsPadding()
                    .padding(horizontal = 20.dp, vertical = 12.dp)
                    .fillMaxWidth()
            ) { Text("Submit") }
        }
    ) { pv ->
        Column(
            modifier = Modifier
                .padding(pv)
                .padding(horizontal = 20.dp, vertical = 16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            StepHeaderRow(current = KycStep.Review)
            KycPanel {
                Row(
                    Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text("KYC summary", style = MaterialTheme.typography.titleMedium, color = Color.White)
                    Icon(Icons.Filled.CheckCircle, null, tint = Color(0xFF34D399))
                }
                Spacer(Modifier.height(8.dp))
                Row(verticalAlignment = Alignment.CenterVertically) {
                    androidx.compose.material3.Checkbox(checked = consent, onCheckedChange = onToggleConsent)
                    Text("I confirm the information is accurate and I consent to verification.", color = Color.White)
                }
            }
        }
    }
}
package com.bankingsystem.mobile.ui.kyc

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.net.Uri
import androidx.core.content.FileProvider
import androidx.exifinterface.media.ExifInterface
import java.io.File
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sqrt

internal fun createImageUri(ctx: Context, name: String): Uri {
    val dir = File(ctx.cacheDir, "images").apply { mkdirs() }
    val file = File(dir, "${name}_${System.currentTimeMillis()}.jpg")
    return FileProvider.getUriForFile(ctx, "${ctx.packageName}.fileprovider", file)
}

fun decodeBitmapForAnalyze(context: Context, uri: Uri, maxDim: Int = 1024): Bitmap? {
    val resolver = context.contentResolver
    val opts = BitmapFactory.Options().apply { inJustDecodeBounds = true }
    resolver.openInputStream(uri)?.use { BitmapFactory.decodeStream(it, null, opts) }
    val w = opts.outWidth
    val h = opts.outHeight
    if (w <= 0 || h <= 0) return null
    var sample = 1
    var largest = max(w, h)
    while (largest / sample > maxDim) sample *= 2
    val opts2 = BitmapFactory.Options().apply { inSampleSize = sample }
    val bmp = resolver.openInputStream(uri)?.use { BitmapFactory.decodeStream(it, null, opts2) } ?: return null
    val rotated = try {
        val orientation = resolver.openInputStream(uri)?.use { ins ->
            ExifInterface(ins).getAttributeInt(
                ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL
            )
        } ?: ExifInterface.ORIENTATION_NORMAL
        val matrix = Matrix().apply {
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> postRotate(270f)
            }
        }
        if (!matrix.isIdentity) Bitmap.createBitmap(bmp, 0, 0, bmp.width, bmp.height, matrix, true) else bmp
    } catch (_: Exception) {
        bmp
    }
    return rotated
}

fun computeDocQuality(bmp: Bitmap): DocQuality {
    val w = bmp.width
    val h = bmp.height
    val px = IntArray(w * h)
    bmp.getPixels(px, 0, w, 0, 0, w, h)
    val g = IntArray(px.size)
    for (i in px.indices) {
        val p = px[i]
        val r = (p shr 16) and 0xFF
        val gch = (p shr 8) and 0xFF
        val b = p and 0xFF
        g[i] = (0.299 * r + 0.587 * gch + 0.114 * b).toInt()
    }
    val blurScore = laplacianVarianceScore(g, w, h)
    val glareScore = 1f - brightFraction(g, threshold = 240)
    val corners = cornerCoverageCount(g, w, h)
    return DocQuality(
        blurScore = blurScore,
        glareScore = glareScore.coerceIn(0f, 1f),
        cornerCoverage = corners
    )
}

private fun laplacianVarianceScore(gray: IntArray, w: Int, h: Int): Float {
    var sum = 0.0
    var sumSq = 0.0
    var n = 0
    for (y in 1 until h - 1) {
        val yi = y * w
        for (x in 1 until w - 1) {
            val i = yi + x
            val v = (-4 * gray[i] +
                    gray[i - 1] + gray[i + 1] +
                    gray[i - w] + gray[i + w]).toDouble()
            sum += v
            sumSq += v * v
            n++
        }
    }
    if (n == 0) return 0f
    val mean = sum / n
    val variance = (sumSq / n) - mean * mean
    val norm = (variance / 2500.0).coerceIn(0.0, 1.0)
    return norm.toFloat()
}

private fun brightFraction(gray: IntArray, threshold: Int): Float {
    var bright = 0
    for (v in gray) if (v >= threshold) bright++
    return bright.toFloat() / gray.size.toFloat()
}

private fun cornerCoverageCount(gray: IntArray, w: Int, h: Int): Int {
    val pw = max(4, (w * 0.15f).toInt())
    val ph = max(4, (h * 0.15f).toInt())
    fun stddev(x0: Int, y0: Int): Double {
        var sum = 0.0
        var sumSq = 0.0
        var n = 0
        for (y in y0 until min(h, y0 + ph)) {
            var i = y * w + x0
            for (x in x0 until min(w, x0 + pw)) {
                val v = gray[i].toDouble()
                sum += v
                sumSq += v * v
                n++
                i++
            }
        }
        if (n == 0) return 0.0
        val mean = sum / n
        val varc = (sumSq / n) - mean * mean
        return sqrt(kotlin.math.max(0.0, varc))
    }
    var count = 0
    if (stddev(0, 0) > 12) count++
    if (stddev(w - pw, 0) > 12) count++
    if (stddev(0, h - ph) > 12) count++
    if (stddev(w - pw, h - ph) > 12) count++
    return count
}
package com.bankingsystem.mobile.ui.kyc

import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.bankingsystem.mobile.data.repository.KycRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

@HiltViewModel
class KycViewModel @Inject constructor(
    private val repo: KycRepository
) : ViewModel() {

    private val _ui = MutableStateFlow(KycUiState())
    val ui: StateFlow<KycUiState> = _ui.asStateFlow()

    private val _uploadedIds = MutableStateFlow<Map<String, String>>(emptyMap())
    val uploadedIds: StateFlow<Map<String, String>> = _uploadedIds.asStateFlow()

    private val _uploading = MutableStateFlow(false)
    val uploading: StateFlow<Boolean> = _uploading.asStateFlow()

    fun go(step: KycStep) = _ui.update { it.copy(step = step) }

    fun next() = _ui.update {
        val s = when (it.step) {
            KycStep.Document -> KycStep.Selfie
            KycStep.Selfie -> KycStep.Address
            KycStep.Address -> KycStep.Review
            KycStep.Review -> KycStep.Review
        }
        it.copy(step = s)
    }

    fun back() = _ui.update {
        val s = when (it.step) {
            KycStep.Document -> KycStep.Document
            KycStep.Selfie -> KycStep.Document
            KycStep.Address -> KycStep.Selfie
            KycStep.Review -> KycStep.Address
        }
        it.copy(step = s)
    }

    fun setDocFront(uri: Uri?) { _ui.update { it.copy(docFront = uri) }; if (uri != null) upload("DOC_FRONT", uri) }
    fun setDocBack(uri: Uri?)  { _ui.update { it.copy(docBack = uri)  }; if (uri != null) upload("DOC_BACK", uri)  }
    fun setSelfie(uri: Uri?)   { _ui.update { it.copy(selfie = uri)   }; if (uri != null) upload("SELFIE", uri)    }
    fun setAddressProof(uri: Uri?) { _ui.update { it.copy(addressProof = uri) }; if (uri != null) upload("ADDRESS_PROOF", uri) }

    fun setDocQuality(q: DocQuality) = _ui.update { it.copy(docQuality = q) }
    fun setOcrFields(fields: List<OcrField>) = _ui.update { it.copy(ocrFields = fields) }
    fun setLiveness(score: Float?) = _ui.update { it.copy(livenessScore = score) }
    fun setFaceMatch(score: Float?) = _ui.update { it.copy(faceMatchScore = score) }
    fun setConsent(accepted: Boolean) = _ui.update { it.copy(consentAccepted = accepted) }

    private fun upload(type: String, uri: Uri) {
        viewModelScope.launch {
            _uploading.value = true
            runCatching { repo.upload(uri, type) }
                .onSuccess { part -> _uploadedIds.update { it + (type to part.id) } }
            _uploading.value = false
        }
    }

    fun canContinueFromDocument(): Boolean {
        val ok = ui.value.docFront != null && ui.value.docBack != null
        val q = ui.value.docQuality
        val blurOk = (q.blurScore ?: 1f) >= 0.10f
        val glareOk = (q.glareScore ?: 1f) >= 0.60f
        val cornersOk = (q.cornerCoverage ?: 0) >= 3
        return ok && blurOk && glareOk && cornersOk
    }

    fun canContinueFromSelfie(): Boolean {
        val liveOk = (ui.value.livenessScore ?: 0f) >= 0.60f
        val matchOk = (ui.value.faceMatchScore ?: 0f) >= 0.60f
        return ui.value.selfie != null && liveOk && matchOk
    }

    fun canContinueFromAddress(): Boolean = ui.value.addressProof != null
    fun canSubmit(): Boolean = ui.value.consentAccepted

    fun docsOk() = ui.value.docFront != null && ui.value.docBack != null
    fun selfieOk(): Boolean {
        val liveOk = (ui.value.livenessScore ?: 1f) >= 0.60f
        val matchOk = (ui.value.faceMatchScore ?: 1f) >= 0.60f
        return ui.value.selfie != null && liveOk && matchOk
    }
    fun addressOk() = ui.value.addressProof != null

    fun readyToSubmit(strict: Boolean = true): Boolean =
        if (strict) {
            docsOk() && selfieOk() && addressOk() && ui.value.consentAccepted
        } else {
            listOf(docsOk(), selfieOk(), addressOk()).count { it } >= 2 && ui.value.consentAccepted
        }

    suspend fun submit(): Boolean {
        if (!readyToSubmit(strict = true)) return false
        val ids = uploadedIds.value
        if (!listOf("DOC_FRONT","DOC_BACK","SELFIE","ADDRESS_PROOF").all { it in ids }) return false
        val okStatuses = setOf("PENDING","AUTO_REVIEW","UNDER_REVIEW","APPROVED","REJECTED")
        return runCatching { repo.submit(ui.value, ids) }
            .map { it.status?.uppercase() in okStatuses }
            .getOrDefault(false)
    }
}
package com.bankingsystem.mobile.data.repository

import android.content.Context
import android.net.Uri
import com.bankingsystem.mobile.data.model.kyc.KycSubmitBody
import com.bankingsystem.mobile.data.service.KycApi
import com.bankingsystem.mobile.ui.kyc.KycUiState
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.MultipartBody
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import okio.source

@Singleton
class KycRepository @Inject constructor(
    private val api: KycApi,
    @ApplicationContext private val ctx: Context
) {
    private fun requestBodyFromUri(uri: Uri): RequestBody {
        val resolver = ctx.contentResolver
        val mime = resolver.getType(uri) ?: "image/jpeg"
        return object : RequestBody() {
            override fun contentType() = mime.toMediaType()
            override fun writeTo(sink: okio.BufferedSink) {
                resolver.openInputStream(uri)?.use { input -> sink.writeAll(input.source()) }
            }
        }
    }

    private fun partFromUri(uri: Uri, name: String): MultipartBody.Part {
        val body = requestBodyFromUri(uri)
        return MultipartBody.Part.createFormData("file", "$name.jpg", body)
    }

    suspend fun upload(uri: Uri, type: String) =
        api.uploadImage(partFromUri(uri, type), type.toRequestBody("text/plain".toMediaType()))

    suspend fun submit(all: KycUiState, ids: Map<String, String>) =
        api.submit(
            KycSubmitBody(
                docFrontId = ids.getValue("DOC_FRONT"),
                docBackId = ids.getValue("DOC_BACK"),
                selfieId = ids.getValue("SELFIE"),
                addressId = ids.getValue("ADDRESS_PROOF"),
                consent = all.consentAccepted
            )
        )
}
package com.bankingsystem.mobile.data.model.kyc

data class UploadedPart(val id: String)

data class KycSubmitBody(
    val docFrontId: String,
    val docBackId: String,
    val selfieId: String,
    val addressId: String,
    val consent: Boolean
)

data class KycSubmitResponse(val status: String)

package com.bankingsystem.mobile.data.service

import com.bankingsystem.mobile.data.model.kyc.KycSubmitBody
import com.bankingsystem.mobile.data.model.kyc.KycSubmitResponse
import com.bankingsystem.mobile.data.model.kyc.UploadedPart
import okhttp3.MultipartBody
import okhttp3.RequestBody
import retrofit2.http.Body
import retrofit2.http.Multipart
import retrofit2.http.POST
import retrofit2.http.Part

interface KycApi {

    @Multipart
    @POST("kyc/upload")
    suspend fun uploadImage(
        @Part file: MultipartBody.Part,
        @Part("type") type: RequestBody // "DOC_FRONT","DOC_BACK","SELFIE","ADDRESS_PROOF"
    ): UploadedPart // { id: String }

    @POST("kyc/submit")
    suspend fun submit(@Body body: KycSubmitBody): KycSubmitResponse
}
